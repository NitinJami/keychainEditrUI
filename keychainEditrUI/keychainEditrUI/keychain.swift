//
//  keychain.swift
//  keychainEditrUI
//
//  Created by Nitin Jami on 2/16/16.
//  Copyright Â© 2016 Ghutle. All rights reserved.
//

import Foundation
import Security

class Keychain: NSObject {
    
    /*
    
        Helper function to provide more useful information out of the
        returned OSStatus codes.
    
        I need to do this because iOS does not support SecCopyErrorMessageString()
    
        TODO:  I am only converting codes that I think are apt for my tool. If I
        encounter anything new, I will update them.
    
        PARAMS: OSStatus code returned by the keychain APIs.
    
        RETURN: A human readable string of the coresponding OSStatus code.
    
    */
    
    private func osstatusToHumanReadable(status: OSStatus) -> String {
        
        // this variable is guaranteed to have a string, hence the
        // implicit unwrapped optional (!)
        let readableString: String!
        
        switch status {
            
        case errSecSuccess:
            readableString = "Operation successfully completed."
            break
        case errSecItemNotFound:
            readableString = "Item not found."
            break
        case errSecInteractionNotAllowed:
            readableString = "Device locked. Item unavailable."
            break
        case errSecItemNotFound:
            readableString = "The specified item could not be found in the keychain."
            break
        case errSecAuthFailed:
            readableString = "Authentication/Authorization failed."
            break
        case errSecParam:
            readableString = "One or more parameters passed to the function were not valid."
            break
        case errSecDuplicateItem:
            readableString = "The item already exists."
            break
        case -34018:
            readableString = "Entitlement not found. Please refer README."
            break
        default:
            readableString = "Unhandled Error: Please contact developer to report this error. Error code: \(status)"
            break
        }
        
        return readableString
    }
    
    /*
    
        Should not be compiled to the release build.
        TODO: Add debug flags.
    
        Function to add an item into the keychain. Used by the developers 
        to test some wierd or corner cases.
    
        PARAMS: Get data from UI textfields, default values are
        used, if no items are provided via UI textfields.
    
        RETURN: A human readable string corresponding to the OSStatus code.
    
    */
    
    func addItem(account: String = "testAccount",
                 service: String = "testService",
                 accessibleConstant: String = kSecAttrAccessibleAlways as String,
                 data: NSData = "test data".dataUsingEncoding(NSUTF8StringEncoding)!
                ) -> String {
        
        // TODO: I still don't understand how to use the error value from the 
        // SecAccessControlCreateWithFlags(). For now, I will use -1 as an 
        // indicator for error generated by SecAccessControlCreateWithFlags()
        var status: OSStatus = -1
                    
        // NOTE: I thought "Unmanged" is not required in Swift 2.0
        // "Unmanged" is mandatory here.
        var error: Unmanaged<CFErrorRef>?
                    
        // NOTE: To avoid the unused variable warning. I just used no varialbe name "_".
        // However, if AccessControl is required then use the variable name "acl".
        if let _ = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
            kSecAttrAccessibleWhenUnlocked, .UserPresence, &error) {
                
                let query = [
                    kSecClass as String         :   kSecClassGenericPassword as String,
                    kSecAttrAccount as String   :   account,
                    kSecAttrService as String   :   service,
                    kSecAttrAccessible as String:   accessibleConstant,
                    // Uncomment the following line to add AccessControl. Make sure 
                    // "acl" is defined above in the if let scope.
                    //kSecAttrAccessControl as String :   acl,
                    kSecValueData as String     :   data
                    ] as NSDictionary
                
                
                status = SecItemDelete(query)
                
                // I really don't care about the second parameter which returns a 
                // pointer to the newly created item.
                // "status" will be overridden, because if I am here that means that
                // there was no error in SecAccessControlCreateWithFlags().
                status = SecItemAdd(query, nil)
                
                if status != errSecSuccess {
                    print("[addItem::SecItemAdd] \(osstatusToHumanReadable(status))")
                }
        } else {
            print("[SecAccessControl] error!")
        }
        
        return osstatusToHumanReadable(status)
    }
    
    /*
    Dump all items.
    RETURN: Array of dictionaries containing keychain items.
    */
    
    func fetchItemAll() -> String {
        
        var query: CFDictionaryRef!
        var returnedItemsInGenericArray: AnyObject? = nil
        var finalArray = [Dictionary<String, AnyObject>]()
        var status: OSStatus!
        
        let secClasses: [NSString]! = [kSecClassGenericPassword]
        let accessiblityConstants: [NSString]! = [kSecAttrAccessibleAfterFirstUnlock,
            kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly,
            kSecAttrAccessibleAlways,
            kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
            kSecAttrAccessibleAlwaysThisDeviceOnly,
            kSecAttrAccessibleWhenUnlocked,
            kSecAttrAccessibleWhenUnlockedThisDeviceOnly]
        
        for eachKSecClass in secClasses {
            for eachConstant in accessiblityConstants {
                
                query = [
                    kSecClass as String             :   eachKSecClass,
                    //kSecAttrAccessible as String    :   eachConstant,
                    //kSecAttrAccount as String       :   "testAccount",
                    kSecMatchLimit as String        :   kSecMatchLimitAll as String,
                    kSecReturnAttributes as String  :   kCFBooleanTrue as Bool,
                    kSecReturnData as String        :   kCFBooleanTrue as Bool
                ]
                
                status = SecItemCopyMatching(query, &returnedItemsInGenericArray)
                
                if status == errSecSuccess {
                    
                    finalArray =  finalArray + ((returnedItemsInGenericArray as! NSArray) as! [Dictionary<String, AnyObject>])
                }
                else {
                    print("[fetchItemAll::\(eachConstant)] \(osstatusToHumanReadable(status))")
                }
                break
            }
        }
        
        for eachDict in finalArray {
            print(eachDict[kSecAttrAccount as String] as! String)
            print(eachDict[kSecAttrService as String] as! String)
            //let sacObj = eachDict[kSecAttrAccessControl as String] as! SecAccessControlRef
            
            //SecAccessControlGetConstraints(sacObj)
            
            //print(sacObj)
            //print(SecAccessControlCreateFlags.UserPresence)
        }
        
        return osstatusToHumanReadable(status)
    }
    
    /*
    Edit a keychain item.
    Params -> (kSecClass=Genp, account, service, data, agroup=nil)
    Return -> String.
    */
    func editItem(items: String...) -> String {
        
        let secClass: String! = items[0]
        let account: String!  = items[1]
        let service: String!  = items[2]
        let updatedData: NSData! = items[3].dataUsingEncoding(NSUTF8StringEncoding)
        
        var query = [
            kSecClass as String         :   secClass,
            kSecAttrAccount as String   :   account,
            kSecAttrService as String   :   service
        ]
        
        if let agroup: String? = items[4] {
            query[kSecAttrAccessGroup as String] = agroup
        }
        
        // Prepare second argument for SecItemUpdate()
        let updatedValue = [kSecValueData as String : updatedData] as CFDictionaryRef
        
        let status: OSStatus = SecItemUpdate(query as CFDictionaryRef, updatedValue)
        
        return osstatusToHumanReadable(status)
    }
    
    /*
    Delete a keychain item.
    Params -> (kSecClass=Genp, account, service, agroup=nil)
    Return -> String.
    */
    func deleteItem(items: String...) -> String {
        
        let secClass: String! = items[0]
        let account: String!  = items[1]
        let service: String!  = items[2]
        
        var query = [
            kSecClass as String         :   secClass,
            kSecAttrAccount as String   :   account,
            kSecAttrService as String   :   service
        ]
        
        if let agroup: String? = items[3] {
            query[kSecAttrAccessGroup as String] = agroup
        }
        
        let status: OSStatus = SecItemDelete(query as CFDictionaryRef)
        
        return osstatusToHumanReadable(status)
    }
}
