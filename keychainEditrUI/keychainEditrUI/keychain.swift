//
//  keychain.swift
//  keychainEditrUI
//
//  Created by Nitin Jami on 2/16/16.
//  Copyright Â© 2016 Ghutle. All rights reserved.
//

import Foundation
import Security

public class Keychain: NSObject {
    
    /*
    
    Helper function to provide more useful information out of the
    returned OSStatus codes.
    
    I need to do this because iOS does not support SecCopyErrorMessageString()
    
    TODO:  I am only converting codes that I think are apt for my tool. If I
    encounter anything new, I will update them.
    
    PARAMS: OSStatus code returned by the keychain APIs.
    
    RETURN: A human readable string of the coresponding OSStatus code.
    
    */
    
    private func osstatusToHumanReadable(status: OSStatus) -> String {
        
        // this variable is guaranteed to have a string, hence the
        // implicit unwrapped optional (!)
        let readableString: String!
        
        switch status {
            
        case errSecSuccess:
            readableString = "Operation successfully completed."
            break
        case errSecItemNotFound:
            readableString = "Item not found."
            break
        case errSecInteractionNotAllowed:
            readableString = "Device locked. Item unavailable."
            break
        case errSecItemNotFound:
            readableString = "The specified item could not be found in the keychain."
            break
        case errSecAuthFailed:
            readableString = "Authentication/Authorization failed."
            break
        case errSecParam:
            readableString = "One or more parameters passed to the function were not valid."
            break
        case errSecDuplicateItem:
            readableString = "The item already exists."
            break
        case -34018:
            readableString = "Entitlement not found. Please refer README."
            break
        case -1:
            readableString = "Error in SecAccessControl!"
            break
        default:
            readableString = "Unhandled Error: Please contact developer to report this error. Error code: \(status)"
            break
        }
        
        return readableString
    }
    
    /*
    
    Should not be compiled to the release build.
    TODO: Add debug flags.
    
    Function to add an item into the keychain. Used by the developers
    to test some wierd or corner cases.
    
    PARAMS: Get data from UI textfields, default values are
    used, if no items are provided via UI textfields.
    
    RETURN: two-tuple (osstatus, human readable status)
    
    */
    
    func addItem(account: String = "testAccount",
        service: String = "testService",
        accessibleConstant: String = kSecAttrAccessibleAlways as String,
        data: NSData = "testData".dataUsingEncoding(NSUTF8StringEncoding)!
        ) -> (status: OSStatus, statusString: String) {
            
            // TODO: I still don't understand how to use the error value from the
            // SecAccessControlCreateWithFlags(). For now, I will use -1 as an
            // indicator for error generated by SecAccessControlCreateWithFlags()
            var status: OSStatus = -1
            
            // NOTE: I thought "Unmanged" is not required in Swift 2.0
            // "Unmanged" is mandatory here.
            var error: Unmanaged<CFErrorRef>?
            
            // NOTE: To avoid the unused variable warning. I just used no varialbe name "_".
            // However, if AccessControl is required then use the variable name "acl".
            if let _ = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
                kSecAttrAccessibleWhenUnlocked, .UserPresence, &error) {
                    
                    let query = [
                        kSecClass as String         :   kSecClassGenericPassword as String,
                        kSecAttrAccount as String   :   account,
                        kSecAttrService as String   :   service,
                        kSecAttrAccessible as String:   accessibleConstant,
                        // Uncomment the following line to add AccessControl. Make sure
                        // "acl" is defined above in the if let scope.
                        //kSecAttrAccessControl as String :   acl,
                        kSecValueData as String     :   data
                        ] as NSDictionary
                    
                    // This is a caution step, to avoid errSecDuplicateItem when
                    // adding an item using SecItemAdd(). Since, this whole method
                    // is for testing purposes there may be cases that the same
                    // item would already exist.
                    status = SecItemDelete(query)
                    
                    if status != errSecSuccess {
                        NSLog("[addItem::SecItemDelete] - \(osstatusToHumanReadable(status))")
                    }
                    
                    // I really don't care about the second parameter which returns a
                    // pointer to the newly created item.
                    // "status" will be overridden, because if I am here that means that
                    // there was no error in SecAccessControlCreateWithFlags().
                    status = SecItemAdd(query, nil)
                    
                    if status != errSecSuccess {
                        NSLog("[addItem::SecItemAdd] \(osstatusToHumanReadable(status))")
                    }
            } else {
                NSLog("[addItem::SecAccessControl] - \(osstatusToHumanReadable(status))")
            }
            return (status, osstatusToHumanReadable(status))
    }
    
    internal func determineTypeAndReturnString(value: AnyObject?) -> String {
        
        if let unwrappedValue = value {
            
            if unwrappedValue.isKindOfClass(NSData) {
                
                if let unwrappedString = String(data: (unwrappedValue as! NSData), encoding: NSASCIIStringEncoding) {
                    
                    return unwrappedString
                } else {
                    return "NIL [Warning] Encoding Shenanigans"
                }
            }
            else if unwrappedValue.isKindOfClass(NSDate) {
                
                let dateFMT = NSDateFormatter()
                dateFMT.dateFormat = "MMM dd, yyyy, hh:mm:ss zzz"
                return dateFMT.stringFromDate(unwrappedValue as! NSDate)
            }
            
            switch (unwrappedValue as! String) {
            case "ak": return "kSecAttrAccessibleWhenUnlocked"
            case "ck": return "kSecAttrAccessibleAfterFirstUnlock"
            case "dk": return "kSecAttrAccessibleAlways"
            case "aku": return "kSecAttrAccessibleWhenUnlockedThisDeviceOnly"
            case "cku": return "kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly"
            case "dku": return "kSecAttrAccessibleAlwaysThisDeviceOnly"
            case "akpu": return "kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly"
            case "": return "NIL"
            default: return (unwrappedValue as! String)
            }
        } else {
            return "NIL"
        }
    }
    
    internal func canonicalizeTypesInReturnedDicts(items: [Dictionary<String, AnyObject>]) -> [Dictionary<String, String>] {
        
        var dict = Dictionary<String, String>()
        var arrayOfDict = [Dictionary<String, String>]()
        
        for eachDict in items {
            
            dict["Account"] = determineTypeAndReturnString(eachDict[kSecAttrAccount as String])
            dict["Service"] = determineTypeAndReturnString(eachDict[kSecAttrService as String])
            dict["Access Group"] = determineTypeAndReturnString(eachDict[kSecAttrAccessGroup as String])
            dict["Creation Time"] = determineTypeAndReturnString(eachDict[kSecAttrCreationDate as String])
            dict["Modification Time"] = determineTypeAndReturnString(eachDict[kSecAttrModificationDate as String])
            dict["Protection"] = determineTypeAndReturnString(eachDict[kSecAttrAccessible as String])
            dict["Data"] = determineTypeAndReturnString(eachDict[kSecValueData as String])
            dict["User Presence"] = "nil" //determineTypeAndReturnString(eachDict[kSecAttrAccessControl as String])

            
            arrayOfDict.append(dict)
        }
        
        return arrayOfDict
    }
    
    /*
    Function to dump all items from the keychain.
    
    PARAMS: None.
    
    RETURN: three tuple (Array of dictionaries items, osstatus, human readable status)
    */
    
    func fetchItemsAll() -> (items: [Dictionary<String, String>], status: OSStatus, statusString: String) {
        
        var query: CFDictionaryRef!
        var returnedItemsInGenericArray: AnyObject? = nil
        var finalArrayOfKeychainItems = [Dictionary<String, AnyObject>]()
        var returnedKeychainItems = [Dictionary<String, String>]()
        var status: OSStatus!
        
        // TODO: Add new kSecClass values here to dump other class items
        // such as certificates, Internet Passwords, etc.
        let secClasses: [NSString]! = [kSecClassGenericPassword]
        
        // When a device is locked, I should be able to dump items that
        // are accessible such as items of type kSecAttrAccessibleAlways
        // and kSecAttrAccessibleAfterFirstUnlock. So dump items based
        // on thier contants, and append them to a final array. Silenty
        // ignore items that are not accessible.
        // Based on issue: https://github.com/NitinJami/keychaineditor/issues/9
        let accessiblityConstants: [NSString]! = [kSecAttrAccessibleAfterFirstUnlock,
            kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly,
            kSecAttrAccessibleAlways,
            kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
            kSecAttrAccessibleAlwaysThisDeviceOnly,
            kSecAttrAccessibleWhenUnlocked,
            kSecAttrAccessibleWhenUnlockedThisDeviceOnly]
        
        // Iterate over the kSecClass and kSecAttrAccessible, and the add
        // returned generic array to a final array.
        for eachKSecClass in secClasses {
            for eachConstant in accessiblityConstants {
                query = [
                    kSecClass as String             :   eachKSecClass,
                    kSecAttrAccessible as String    :   eachConstant,
                    kSecMatchLimit as String        :   kSecMatchLimitAll as String,
                    kSecReturnAttributes as String  :   kCFBooleanTrue as Bool,
                    kSecReturnData as String        :   kCFBooleanTrue as Bool
                ]
                
                status = SecItemCopyMatching(query, &returnedItemsInGenericArray)
                
                if status == errSecSuccess {
                    finalArrayOfKeychainItems =  finalArrayOfKeychainItems
                        // first unwrap and cast generice array to type NSArray.
                        // and then, cast it to Array of dictionaries.
                        + ((returnedItemsInGenericArray as! NSArray) as! [Dictionary<String, AnyObject>])
                }
                else {
                    NSLog("[fetchItemAll::\(eachConstant)] \(osstatusToHumanReadable(status))")
                }
            }
        }
        
        /*
        for eachDict in finalArrayOfKeychainItems {
        print(eachDict[kSecAttrAccount as String] as! String)
        print(eachDict[kSecAttrService as String] as! String)
        //let sacObj = eachDict[kSecAttrAccessControl as String] as! SecAccessControlRef
        
        //SecAccessControlGetConstraints(sacObj)
        
        //print(sacObj)
        //print(SecAccessControlCreateFlags.UserPresence)
        }
        */
        
        // The value of status is not really the actual status that I like to
        // have. The status varies according to constant that I am dumping with.
        // Hence, if the final array contains at least one value, then I will consider
        // it as a success. Or else, just return the last status value.
        
        if (finalArrayOfKeychainItems.count >= 1) {
            status = errSecSuccess
            
            returnedKeychainItems = canonicalizeTypesInReturnedDicts(finalArrayOfKeychainItems)
        }
        
        return (returnedKeychainItems, status, osstatusToHumanReadable(status))
    }
    
    /*
    Function for updating an existing keychain item.
    
    Params -> (kSecClass=Genp, account, service, data, agroup=nil)
    
    Return -> String.
    */
    func updateItem(secClass: String = kSecClassGenericPassword as String,
        account: String,
        service: String,
        data: String,
        agroup: String? = nil) -> (status: OSStatus, statusString: String) {
            
            
            // The value of kSecValueData should be of type NSData.
            let dataAsNSData: NSData! = data.dataUsingEncoding(NSUTF8StringEncoding)
            
            // Build the query with optional kSecAttrAccessGroup.
            var query = [
                kSecClass as String         :   secClass,
                kSecAttrAccount as String   :   account,
                kSecAttrService as String   :   service
            ]
            
            // If the agroup is set, then include it in the query.
            if let unwrappedAGroup = agroup {
                query[kSecAttrAccessGroup as String] = unwrappedAGroup
            }
            
            // Prepare second argument for SecItemUpdate()
            let dataToUpdate = [kSecValueData as String : dataAsNSData] as CFDictionaryRef
            
            let status: OSStatus = SecItemUpdate(query as CFDictionaryRef, dataToUpdate)
            
            if (status != errSecSuccess) {
                NSLog("[updateItem::SecItemUpdate] - \(osstatusToHumanReadable(status))")
            }
            
            return (status, osstatusToHumanReadable(status))
    }
    
    /*
    Function for updating an existing keychain item.
    
    Params -> (kSecClass=Genp, account, service, agroup=nil)
    
    Return -> String.
    */
    func removeItem(secClass: String = kSecClassGenericPassword as String,
        account: String,
        service: String,
        agroup: String? = nil) -> (status: OSStatus, statusString: String) {
            
            // Build the query with optional kSecAttrAccessGroup.
            var query = [
                kSecClass as String         :   secClass,
                kSecAttrAccount as String   :   account,
                kSecAttrService as String   :   service
            ]
            
            // If the agroup is set, then include it in the query.
            if let unwrappedAGroup = agroup {
                query[kSecAttrAccessGroup as String] = unwrappedAGroup
            }
            
            let status: OSStatus = SecItemDelete(query as CFDictionaryRef)
            
            if (status != errSecSuccess) {
                NSLog("[removeItem::SecItemDelete] - \(osstatusToHumanReadable(status))")
            }
            
            return (status, osstatusToHumanReadable(status))
    }
}
